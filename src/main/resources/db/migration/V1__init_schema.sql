-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;

CREATE TABLE IF NOT EXISTS public.customers
(
    customer_id uuid NOT NULL,
    default_payment_method character varying(50) COLLATE pg_catalog."default",
    rating numeric(3, 2) DEFAULT 5.0,
    total_trips integer DEFAULT 0,
    version bigint DEFAULT 0,
    CONSTRAINT customers_pkey PRIMARY KEY (customer_id)
);

CREATE TABLE IF NOT EXISTS public.driver_locations
(
    driver_id uuid NOT NULL,
    current_location geography NOT NULL,
    last_updated timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    is_available boolean DEFAULT true,
    heading double precision,
    CONSTRAINT driver_locations_pkey PRIMARY KEY (driver_id)
);

CREATE TABLE IF NOT EXISTS public.drivers
(
    driver_id uuid NOT NULL,
    license_number character varying(50) COLLATE pg_catalog."default" NOT NULL,
    vehicle_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    vehicle_brand character varying(50) COLLATE pg_catalog."default",
    vehicle_model character varying(50) COLLATE pg_catalog."default",
    vehicle_plate character varying(20) COLLATE pg_catalog."default" NOT NULL,
    rating numeric(3, 2) DEFAULT 5.0,
    total_trips integer DEFAULT 0,
    current_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'offline'::character varying,
    documents_verified boolean DEFAULT false,
    CONSTRAINT drivers_pkey PRIMARY KEY (driver_id),
    CONSTRAINT drivers_license_number_key UNIQUE (license_number),
    CONSTRAINT drivers_vehicle_plate_key UNIQUE (vehicle_plate)
);

CREATE TABLE IF NOT EXISTS public.location_history
(
    location_id uuid NOT NULL,
    user_id uuid NOT NULL,
    location geography NOT NULL,
    speed double precision,
    heading real,
    recorded_at timestamp with time zone NOT NULL DEFAULT now(),
    trip_id uuid,
    CONSTRAINT location_history_pkey PRIMARY KEY (location_id)
);

CREATE TABLE IF NOT EXISTS public.messages
(
    message_id uuid NOT NULL DEFAULT gen_random_uuid(),
    trip_id uuid NOT NULL,
    sender_id uuid NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    is_read boolean,
    read_at timestamp with time zone,
    recipient_id uuid NOT NULL,
    CONSTRAINT messages_pkey PRIMARY KEY (message_id)
);

CREATE TABLE IF NOT EXISTS public.notifications
(
    notification_id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL,
    title character varying COLLATE pg_catalog."default" NOT NULL,
    type character varying COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    is_read boolean DEFAULT false,
    message text COLLATE pg_catalog."default" NOT NULL,
    read_at timestamp with time zone,
    related_id uuid,
    CONSTRAINT notifications_pkey PRIMARY KEY (notification_id)
);

CREATE TABLE IF NOT EXISTS public.payment_methods
(
    method_id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL,
    type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    card_number character varying(255) COLLATE pg_catalog."default",
    is_default boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    card_holder_name character varying(255) COLLATE pg_catalog."default",
    expiry_date character varying(255) COLLATE pg_catalog."default",
    wallet_id character varying(255) COLLATE pg_catalog."default",
    wallet_name character varying(255) COLLATE pg_catalog."default",
    updated_at timestamp with time zone,
    CONSTRAINT payment_methods_pkey PRIMARY KEY (method_id)
);

CREATE TABLE IF NOT EXISTS public.payments
(
    payment_id uuid NOT NULL DEFAULT gen_random_uuid(),
    trip_id uuid NOT NULL,
    amount numeric(10, 2) NOT NULL,
    payment_method character varying(50) COLLATE pg_catalog."default" NOT NULL,
    status character varying(20) COLLATE pg_catalog."default" NOT NULL DEFAULT 'pending'::character varying,
    transaction_id character varying(100) COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    processed_at timestamp with time zone,
    CONSTRAINT payments_pkey PRIMARY KEY (payment_id)
);

CREATE TABLE IF NOT EXISTS public.ratings
(
    rating_id uuid NOT NULL DEFAULT gen_random_uuid(),
    trip_id uuid NOT NULL,
    rater_id uuid NOT NULL,
    rated_user_id uuid NOT NULL,
    rating_value integer NOT NULL,
    comment text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ratings_pkey PRIMARY KEY (rating_id)
);

CREATE TABLE IF NOT EXISTS public.trips
(
    trip_id uuid NOT NULL DEFAULT gen_random_uuid(),
    customer_id uuid NOT NULL,
    driver_id uuid NOT NULL,
    pickup_location geography NOT NULL,
    dropoff_location geography NOT NULL,
    pickup_address text COLLATE pg_catalog."default" NOT NULL,
    dropoff_address text COLLATE pg_catalog."default" NOT NULL,
    status character varying(20) COLLATE pg_catalog."default" NOT NULL DEFAULT 'pending'::character varying,
    vehicle_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    estimated_distance double precision NOT NULL,
    estimated_duration integer NOT NULL,
    estimated_fare numeric(10, 2) NOT NULL,
    actual_fare numeric(10, 2),
    route geography,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    accepted_at timestamp with time zone,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    cancelled_at timestamp with time zone,
    cancelled_by uuid,
    cancellation_reason text COLLATE pg_catalog."default",
    actual_distance double precision,
    actual_duration integer,
    CONSTRAINT trips_pkey PRIMARY KEY (trip_id)
);

CREATE TABLE IF NOT EXISTS public.users
(
    user_id uuid NOT NULL DEFAULT gen_random_uuid(),
    phone_number character varying(15) COLLATE pg_catalog."default" NOT NULL,
    email character varying(255) COLLATE pg_catalog."default",
    password_hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    full_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    avatar_url text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    status character varying(20) COLLATE pg_catalog."default" DEFAULT 'active'::character varying,
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_phone_number_key UNIQUE (phone_number)
);

ALTER TABLE IF EXISTS public.customers
    ADD CONSTRAINT customers_customer_id_fkey FOREIGN KEY (customer_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS customers_pkey
    ON public.customers(customer_id);


ALTER TABLE IF EXISTS public.driver_locations
    ADD CONSTRAINT driver_locations_driver_id_fkey FOREIGN KEY (driver_id)
        REFERENCES public.drivers (driver_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS driver_locations_pkey
    ON public.driver_locations(driver_id);


ALTER TABLE IF EXISTS public.drivers
    ADD CONSTRAINT drivers_driver_id_fkey FOREIGN KEY (driver_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS drivers_pkey
    ON public.drivers(driver_id);


ALTER TABLE IF EXISTS public.location_history
    ADD CONSTRAINT location_history_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.messages
    ADD CONSTRAINT fk_message_recipient FOREIGN KEY (recipient_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.messages
    ADD CONSTRAINT fk_message_sender FOREIGN KEY (sender_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.messages
    ADD CONSTRAINT fk_message_trip FOREIGN KEY (trip_id)
        REFERENCES public.trips (trip_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_messages_trip_id
    ON public.messages(trip_id);


ALTER TABLE IF EXISTS public.messages
    ADD CONSTRAINT messages_sender_id_fkey FOREIGN KEY (sender_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.messages
    ADD CONSTRAINT messages_trip_id_fkey FOREIGN KEY (trip_id)
        REFERENCES public.trips (trip_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_messages_trip_id
    ON public.messages(trip_id);


ALTER TABLE IF EXISTS public.notifications
    ADD CONSTRAINT fk_notification_user FOREIGN KEY (user_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_notifications_user_id
    ON public.notifications(user_id);


ALTER TABLE IF EXISTS public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_notifications_user_id
    ON public.notifications(user_id);


ALTER TABLE IF EXISTS public.payment_methods
    ADD CONSTRAINT payment_methods_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.payments
    ADD CONSTRAINT payments_trip_id_fkey FOREIGN KEY (trip_id)
        REFERENCES public.trips (trip_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payments_trip_id
    ON public.payments(trip_id);


ALTER TABLE IF EXISTS public.ratings
    ADD CONSTRAINT ratings_rated_user_id_fkey FOREIGN KEY (rated_user_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_ratings_rated_user_id
    ON public.ratings(rated_user_id);


ALTER TABLE IF EXISTS public.ratings
    ADD CONSTRAINT ratings_rater_id_fkey FOREIGN KEY (rater_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_ratings_rater_id
    ON public.ratings(rater_id);


ALTER TABLE IF EXISTS public.ratings
    ADD CONSTRAINT ratings_trip_id_fkey FOREIGN KEY (trip_id)
        REFERENCES public.trips (trip_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_ratings_trip_id
    ON public.ratings(trip_id);


ALTER TABLE IF EXISTS public.trips
    ADD CONSTRAINT trips_cancelled_by_fkey FOREIGN KEY (cancelled_by)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.trips
    ADD CONSTRAINT trips_customer_id_fkey FOREIGN KEY (customer_id)
        REFERENCES public.customers (customer_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_trips_customer_id
    ON public.trips(customer_id);


ALTER TABLE IF EXISTS public.trips
    ADD CONSTRAINT trips_driver_id_fkey FOREIGN KEY (driver_id)
        REFERENCES public.drivers (driver_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_trips_driver_id
    ON public.trips(driver_id);

CREATE OR REPLACE FUNCTION public.find_nearest_drivers(
    pickup_point geography,
    max_distance_meters double precision,
    required_vehicle_type character varying DEFAULT NULL
)
    RETURNS TABLE(
                     driver_id uuid,
                     longitude double precision,
                     latitude double precision,
                     heading double precision,
                     vehicle_type character varying,
                     vehicle_plate character varying,
                     distance double precision
                 )
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY
        SELECT
            dl.driver_id,
            ST_X(dl.current_location::geometry) as longitude,
            ST_Y(dl.current_location::geometry) as latitude,
            dl.heading,
            d.vehicle_type,
            d.vehicle_plate,
            ST_Distance(dl.current_location, pickup_point) as distance
        FROM driver_locations dl
                 JOIN drivers d ON d.driver_id = dl.driver_id
        WHERE d.current_status = 'online'
          AND dl.is_available = true
          AND (required_vehicle_type IS NULL OR d.vehicle_type = required_vehicle_type)
          AND ST_DWithin(dl.current_location, pickup_point, max_distance_meters)
        ORDER BY dl.current_location <-> pickup_point
        LIMIT 50;
END;
$BODY$;

ALTER FUNCTION public.find_nearest_drivers(geography, double precision, character varying)
    OWNER TO rideconnect_admin;

END;